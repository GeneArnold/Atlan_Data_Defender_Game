<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlan Data Defender</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw;
            max-height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: auto;
        }
        .btn {
            width: 80px;
            height: 80px;
            background: rgba(0, 100, 255, 0.8);
            border: 2px solid #00ffff;
            border-radius: 50%;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
            pointer-events: auto;
        }
        .btn:active {
            background: rgba(0, 150, 255, 1);
            transform: scale(0.95);
        }
        .btn.fire {
            background: rgba(255, 50, 50, 0.8);
            border-color: #ff0000;
        }
        .btn.fire:active {
            background: rgba(255, 100, 100, 1);
        }
        .start-btn, .music-btn, .quit-btn {
            position: fixed;
            z-index: 101;
            pointer-events: auto;
        }
        .start-btn {
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 50px;
            background: rgba(255, 255, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 10px;
            color: #000;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .start-btn:active {
            background: rgba(255, 255, 100, 1);
            transform: translateX(-50%) scale(0.95);
        }
        .start-btn.hidden {
            display: none;
        }
        .music-btn {
            top: 5px;
            right: 80px;
            width: 70px;
            height: 25px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
            border-radius: 5px;
            color: #0f0;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .music-btn:active {
            background: rgba(0, 255, 0, 0.4);
        }
        .music-btn.off {
            background: rgba(255, 0, 0, 0.2);
            border-color: #f00;
            color: #f00;
        }
        .music-btn.off:active {
            background: rgba(255, 0, 0, 0.4);
        }
        .quit-btn {
            top: 5px;
            right: 10px;
            width: 60px;
            height: 25px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .quit-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div class="controls">
        <div class="btn" id="leftBtn">LEFT</div>
        <div class="btn" id="rightBtn">RIGHT</div>
        <div class="btn fire" id="fireBtn">FIRE</div>
    </div>
    <div class="start-btn" id="startBtn">START GAME</div>
    <div class="music-btn" id="musicBtn">MUSIC ON</div>
    <div class="quit-btn" id="quitBtn">QUIT</div>
    <div id="version" style="position:fixed;bottom:5px;right:10px;font-size:12px;color:#aaa;z-index:200;pointer-events:none;">v<span id="versionNum"></span></div>

    <script>
        // === GLOBAL LAYOUT CONSTANTS ===
        // Adjust these to tune layout easily
        const GAME_VERSION = '1.1.3'; // Game version number (logo raised above DATA DEFENDER, filename atlan_logo.svg)
        const PLAYER_Y_RATIO = 0.75; // 0.90 = near bottom, 0.5 = middle, 0.1 = near top
        // === ENEMY/WAVE CONFIGURATION ===
        // Set the number of bad guys needed to complete each wave here:
        const BAD_GUYS_PER_WAVE = [
            25, // Wave 1
            30, // Wave 2
            35, // Wave 3
            40, // Wave 4
            45, // Wave 5
            50, // Wave 6
            55, // Wave 7
            60, // Wave 8
            65, // Wave 9
            70, // Wave 10
            75, // Wave 11
            80, // Wave 12
            85  // Wave 13+
        ];
        // (You could add BUTTON_SIZE, MARGIN, etc. here for further tuning)
        
        // Game state
        let gameState = 'title';
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let score = 0;
        let wave = 1;
        let lives = 3;
        let waveTimer = 0;
        let waveAnnouncement = '';
        let invulnerableTimer = 0;
        let gameOverTimer = 0;
        let enemiesKilled = 0;
        let enemiesNeededForWave = 25;
        let hitTimer = 0;
        let explosions = [];
        
        // Controls
        let leftPressed = false;
        let rightPressed = false;
        let firePressed = false;
        
        // Audio
        let audioContext;
        let backgroundMusic;
        let musicEnabled = true;
        
        // Game settings
        let canvasWidth = 400;
        let canvasHeight = 600;
        
        // Data catalog-themed enemy definitions
        const ENEMY_TYPES = [
            { type: 'pii', label: 'PII Breach', color: [120, 0, 0], points: 30 }, // deep red
            { type: 'quality', label: 'Bad Quality', color: [60, 60, 60], points: 20 }, // dark gray
            { type: 'lost', label: 'Lost Data', color: [70, 35, 10], points: 10 }, // dark brown
            { type: 'orphan', label: 'Orphaned Table', color: [0, 80, 120], points: 25 }, // dark cyan
            { type: 'unclassified', label: 'Unclassified File', color: [120, 90, 0], points: 18 }, // dark gold
            { type: 'stale', label: 'Stale Report', color: [60, 60, 100], points: 15 }, // dark blue-gray
            { type: 'lineage', label: 'Broken Lineage', color: [90, 0, 80], points: 22 }, // dark magenta
            { type: 'duplicate', label: 'Duplicate Asset', color: [0, 80, 30], points: 16 }, // dark green
            { type: 'unapproved', label: 'Unapproved Query', color: [120, 40, 0], points: 20 }, // dark orange
            { type: 'policy', label: 'Policy Violation', color: [120, 0, 0], points: 28 }, // deep red
            { type: 'uncertified', label: 'Uncertified Data', color: [30, 30, 80], points: 19 }, // dark blue
            { type: 'unknown', label: 'Unknown Owner', color: [30, 80, 80], points: 17 } // dark teal
        ];
        
        // === MUSIC CONFIGURATION ===
        // Darker, minor-key arcade melody (A C E F E C)
        const MAIN_MELODY = [
            220, // A3
            261.63, // C4
            329.63, // E4
            349.23, // F4
            329.63, // E4
            261.63  // C4
        ];
        // Darker victory melody (A C F A4)
        const VICTORY_MELODY = [
            220, // A3
            261.63, // C4
            349.23, // F4
            440    // A4
        ];
        let melodyIndex = 0;
        let melodyInterval = null;
        let melodyTempo = 400; // ms per note
        const MIN_TEMPO = 120; // Fastest allowed (ms per note)
        let playingVictory = false;
        
        // Atlan logo SVG
        let atlanLogoImg;
        
        function preload() {
            atlanLogoImg = loadImage('images/atlan_logo.svg');
        }
        
        function setup() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('gameContainer');
            player = {
                x: canvasWidth / 2,
                y: canvasHeight * PLAYER_Y_RATIO, // Use global var for vertical placement
                width: 40,
                height: 30,
                speed: 4
            };
            setupControls();
            // At the end of setup() or after DOM is ready, set the version number
            window.addEventListener('DOMContentLoaded', () => {
                document.getElementById('versionNum').textContent = GAME_VERSION;
            });
        }
        
        function draw() {
            background(10, 10, 30);
            drawStars();
            
            if (gameState === 'title') {
                drawTitle();
                document.getElementById('startBtn').classList.remove('hidden');
            } else if (gameState === 'playing') {
                updateGame();
                drawGame();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'waveAnnounce') {
                drawWaveAnnouncement();
                updateWaveTimer();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'playerHit') {
                drawPlayerHit();
                updateHitTimer();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'gameOver') {
                drawGameOver();
                updateGameOverTimer();
                document.getElementById('startBtn').classList.remove('hidden');
            }
            
            if (gameState !== 'gameOver') {
                drawScore();
            }
        }
        
        function updateGame() {
            // Controls
            if (leftPressed && player.x > player.width/2) {
                player.x -= player.speed;
            }
            if (rightPressed && player.x < canvasWidth - player.width/2) {
                player.x += player.speed;
            }
            if (firePressed && bullets.length === 0) {
                bullets.push({
                    x: player.x,
                    y: player.y - 10,
                    speed: 8
                });
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                if (bullets[i].y < 0) {
                    bullets.splice(i, 1);
                }
            }
            
            // Spawn enemies
            if (frameCount % max(30 - wave * 3, 10) === 0) {
                spawnEnemy();
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;
                
                if (enemies[i].y > canvasHeight + 50) {
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Player collision
                if (invulnerableTimer <= 0 && dist(enemies[i].x, enemies[i].y, player.x, player.y) < 30) {
                    lives--;
                    invulnerableTimer = 180;
                    createExplosion(player.x, player.y, 'player');
                    playDeathSound();
                    enemies.splice(i, 1);
                    
                    if (lives <= 0) {
                        lives = 0;
                        gameState = 'gameOver';
                        gameOverTimer = 300;
                        stopBackgroundMusic();
                        return;
                    } else {
                        // Clear all enemies when player is hit
                        enemies = [];
                        gameState = 'playerHit';
                        hitTimer = 120;
                        return;
                    }
                    continue;
                }
            }
            
            if (invulnerableTimer > 0) {
                invulnerableTimer--;
            }
            
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (dist(bullets[i].x, bullets[i].y, enemies[j].x, enemies[j].y) < 20) {
                        // Add explosion sprite at enemy position
                        explosions.push({
                            x: enemies[j].x,
                            y: enemies[j].y,
                            timer: 30, // 0.5 sec at 60fps
                            frame: 0
                        });
                        playHitSound();
                        score += enemies[j].points;
                        enemiesKilled++;
                        
                        if (enemiesKilled >= enemiesNeededForWave) {
                            playVictoryMelody();
                            nextWave();
                        }
                        
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        break;
                    }
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life--;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].timer--;
                explosions[i].frame++;
                if (explosions[i].timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function drawGame() {
            // Draw player
            if (invulnerableTimer <= 0 || frameCount % 10 < 5) {
                drawAtlanShip(player.x, player.y);
            }
            
            // Draw bullets
            fill(255, 255, 0);
            noStroke();
            for (let bullet of bullets) {
                rect(bullet.x - 2, bullet.y - 6, 4, 12);
            }
            
            // Draw enemies
            for (let enemy of enemies) {
                drawEnemy(enemy);
            }
            
            // Draw explosions
            for (let explosion of explosions) {
                drawExplosion(explosion);
            }
            
            // Draw particles
            for (let particle of particles) {
                fill(particle.r, particle.g, particle.b, particle.life * 3);
                noStroke();
                rect(particle.x, particle.y, 3, 3);
            }
        }
        
        function drawAtlanShip(x, y) {
            push();
            translate(x, y);
            
            // Main body
            fill(0, 150, 255);
            noStroke();
            beginShape();
            vertex(-15, -10);  // Top left
            vertex(15, -10);   // Top right
            vertex(20, 0);     // Right middle
            vertex(15, 10);    // Bottom right
            vertex(-15, 10);   // Bottom left
            vertex(-20, 0);    // Left middle
            endShape(CLOSE);
            
            // Cockpit
            fill(255, 255, 255);
            beginShape();
            vertex(-8, -6);
            vertex(8, -6);
            vertex(6, 6);
            vertex(-6, 6);
            endShape(CLOSE);
            
            // Wings
            fill(0, 100, 200);
            beginShape();
            vertex(-20, 0);
            vertex(-25, 5);
            vertex(-20, 10);
            endShape(CLOSE);
            
            beginShape();
            vertex(20, 0);
            vertex(25, 5);
            vertex(20, 10);
            endShape(CLOSE);
            
            // Engines
            fill(255, 100, 0);
            rect(-6, 10, 4, 8);
            rect(2, 10, 4, 8);
            
            // Engine glow
            fill(255, 200, 0, 150);
            rect(-6, 18, 4, 4);
            rect(2, 18, 4, 4);
            
            pop();
        }
        
        function drawEnemy(enemy) {
            push();
            translate(enemy.x, enemy.y);
            noStroke();
            // ALIEN/EVIL ENEMY REDESIGNS
            if (enemy.type === 'pii') {
                // Red demon head with horns and glowing yellow eyes
                fill(220, 0, 0);
                ellipse(0, 0, 28, 28);
                fill(255, 255, 0);
                ellipse(-7, -4, 6, 8); // left eye
                ellipse(7, -4, 6, 8); // right eye
                fill(120, 0, 0);
                arc(0, 8, 16, 10, 0, PI, CHORD); // mouth
                fill(255, 255, 255);
                triangle(-10, -14, -4, -18, -2, -8); // left horn
                triangle(10, -14, 4, -18, 2, -8); // right horn
            } else if (enemy.type === 'quality') {
                // Gray cyclops blob with a big green eye and fangs
                fill(80, 80, 80);
                ellipse(0, 0, 30, 24);
                fill(0, 255, 0);
                ellipse(0, -2, 10, 10); // big eye
                fill(0);
                ellipse(0, -2, 4, 4); // pupil
                fill(255);
                triangle(-4, 8, -2, 12, 0, 8); // left fang
                triangle(4, 8, 2, 12, 0, 8); // right fang
            } else if (enemy.type === 'lost') {
                // Brown spiky virus with glowing orange core
                fill(120, 60, 20);
                ellipse(0, 0, 24, 24);
                for (let a = 0; a < TWO_PI; a += PI/4) {
                    let x1 = cos(a) * 12, y1 = sin(a) * 12;
                    let x2 = cos(a) * 18, y2 = sin(a) * 18;
                    stroke(120, 60, 20);
                    strokeWeight(3);
                    line(x1, y1, x2, y2);
                }
                noStroke();
                fill(255, 140, 0, 180);
                ellipse(0, 0, 10, 10);
            } else if (enemy.type === 'orphan') {
                // Blue floating jellyfish with tentacles and glowing eyes
                fill(0, 180, 255);
                ellipse(0, 0, 26, 18);
                fill(255, 255, 255, 200);
                ellipse(-5, -2, 5, 5);
                ellipse(5, -2, 5, 5);
                stroke(0, 180, 255);
                strokeWeight(2);
                for (let t = -1; t <= 1; t++) {
                    line(t*6, 8, t*6 + random(-2,2), 18 + random(0,2));
                }
                noStroke();
            } else if (enemy.type === 'unclassified') {
                // Yellow-green alien with three eyes and a jagged mouth
                fill(200, 220, 0);
                ellipse(0, 0, 24, 24);
                fill(0, 255, 0);
                ellipse(-6, -4, 4, 4);
                ellipse(0, -7, 4, 4);
                ellipse(6, -4, 4, 4);
                fill(0);
                beginShape();
                vertex(-6, 7);
                vertex(-3, 10);
                vertex(0, 7);
                vertex(3, 10);
                vertex(6, 7);
                endShape();
            } else if (enemy.type === 'stale') {
                // Purple bat-like alien with wings
                fill(120, 0, 180);
                ellipse(0, 0, 22, 16);
                fill(180, 0, 255, 180);
                triangle(-11, 0, -22, 8, -8, 8);
                triangle(11, 0, 22, 8, 8, 8);
                fill(255, 255, 255);
                ellipse(-4, -2, 3, 3);
                ellipse(4, -2, 3, 3);
            } else if (enemy.type === 'lineage') {
                // Magenta tentacled alien with a single red eye
                fill(200, 0, 120);
                ellipse(0, 0, 20, 20);
                stroke(200, 0, 120);
                strokeWeight(2);
                for (let t = -1; t <= 1; t++) {
                    line(t*6, 8, t*6 + random(-2,2), 18 + random(0,2));
                }
                noStroke();
                fill(255, 0, 0);
                ellipse(0, -3, 6, 6);
                fill(0);
                ellipse(0, -3, 2, 2);
            } else if (enemy.type === 'duplicate') {
                // Green two-headed alien
                fill(0, 220, 80);
                ellipse(-5, 0, 12, 16);
                ellipse(5, 0, 12, 16);
                fill(255);
                ellipse(-5, -4, 3, 3);
                ellipse(5, -4, 3, 3);
                fill(255, 0, 0);
                ellipse(-5, 2, 2, 2);
                ellipse(5, 2, 2, 2);
            } else if (enemy.type === 'unapproved') {
                // Orange spiky alien with angry eyes
                fill(255, 120, 0);
                ellipse(0, 0, 22, 22);
                for (let a = 0; a < TWO_PI; a += PI/5) {
                    let x1 = cos(a) * 11, y1 = sin(a) * 11;
                    let x2 = cos(a) * 15, y2 = sin(a) * 15;
                    stroke(255, 120, 0);
                    strokeWeight(2);
                    line(x1, y1, x2, y2);
                }
                noStroke();
                fill(0);
                ellipse(-4, -3, 3, 4);
                ellipse(4, -3, 3, 4);
                fill(255, 0, 0);
                rect(-3, 4, 6, 2, 1);
            } else if (enemy.type === 'policy') {
                // Red skull with glowing eyes
                fill(255, 0, 0);
                ellipse(0, 0, 22, 22);
                fill(255, 255, 0);
                ellipse(-5, -3, 4, 4);
                ellipse(5, -3, 4, 4);
                fill(0);
                rect(-6, 4, 12, 4, 2);
                rect(-2, 8, 4, 2, 1);
            } else if (enemy.type === 'uncertified') {
                // Blue floating orb with a glowing core and aura
                fill(0, 80, 255);
                ellipse(0, 0, 20, 20);
                fill(0, 200, 255, 120);
                ellipse(0, 0, 12, 12);
                fill(255, 255, 255, 180);
                ellipse(0, 0, 6, 6);
            } else if (enemy.type === 'unknown') {
                // Teal alien with a single big eye and question mark
                fill(0, 200, 200);
                ellipse(0, 0, 22, 22);
                fill(255);
                ellipse(0, -3, 7, 7);
                fill(0);
                ellipse(0, -3, 3, 3);
                fill(255, 255, 0);
                textSize(14);
                text('?', 0, 8);
            }
            // Draw label under enemy
            pop();
            push();
            translate(enemy.x, enemy.y);
            fill(255);
            textAlign(CENTER);
            textSize(10);
            text(enemy.label, 0, 22);
            pop();
        }
        
        function drawTitle() {
            if (frameCount % 60 === 0) {
                const typeObj = random(ENEMY_TYPES.slice(0, 3)); // Only the first 3 for title screen
                enemies.push({
                    x: random(50, canvasWidth - 50),
                    y: -30,
                    type: typeObj.type,
                    label: typeObj.label,
                    color: typeObj.color,
                    speed: 0.5,
                    points: typeObj.points
                });
            }
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;
                drawEnemy(enemies[i]);
                if (enemies[i].y > canvasHeight + 50) {
                    enemies.splice(i, 1);
                }
            }
            // Draw Atlan SVG logo centered above DATA DEFENDER
            if (atlanLogoImg) {
                textSize(20);
                let dataDefenderWidth = textWidth("DATA DEFENDER");
                let logoW = dataDefenderWidth * 2;
                let logoH = logoW * (atlanLogoImg.height / atlanLogoImg.width);
                image(atlanLogoImg, canvasWidth/2 - logoW/2, canvasHeight/2 - 170, logoW, logoH);
            }
            fill(255, 255, 255);
            textAlign(CENTER);
            textSize(20);
            text("DATA DEFENDER", canvasWidth/2, canvasHeight/2 - 35);
            fill(255, 255, 0);
            textSize(14);
            text("Protect Your Data!", canvasWidth/2, canvasHeight/2 - 10);
            fill(255, 255, 0);
            textSize(14);
            text("version " + GAME_VERSION, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function drawPlayerHit() {
            for (let enemy of enemies) {
                drawEnemy(enemy);
            }
            
            for (let particle of particles) {
                fill(particle.r, particle.g, particle.b, particle.life * 3);
                noStroke();
                rect(particle.x, particle.y, 3, 3);
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life--;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            fill(255, 100, 100);
            textAlign(CENTER);
            textSize(24);
            text("SHIP HIT!", canvasWidth/2, canvasHeight/2 - 20);
            
            fill(255, 255, 255);
            textSize(16);
            text(`Lives Remaining: ${lives}`, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function updateHitTimer() {
            hitTimer--;
            if (hitTimer <= 0) {
                gameState = 'playing';
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
            }
        }
        
        function drawWaveAnnouncement() {
            fill(255, 255, 0);
            textAlign(CENTER);
            textSize(20);
            text(`WAVE ${wave}`, canvasWidth/2, canvasHeight/2 - 20);
            textSize(14);
            text(waveAnnouncement, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function updateWaveTimer() {
            waveTimer--;
            if (waveTimer <= 0) {
                gameState = 'playing';
            }
        }
        
        function drawGameOver() {
            fill(255, 0, 0);
            textAlign(CENTER);
            textSize(28);
            text("GAME OVER", canvasWidth/2, canvasHeight/2 - 80);
            
            fill(255);
            textSize(18);
            text(`Final Score: ${score}`, canvasWidth/2, canvasHeight/2 - 40);
            text(`Waves Survived: ${wave}`, canvasWidth/2, canvasHeight/2 - 15);
        }
        
        function updateGameOverTimer() {
            gameOverTimer--;
            if (gameOverTimer <= 0) {
                lives = 3;
                gameState = 'title';
            }
        }
        
        function nextWave() {
            wave++;
            enemiesKilled = 0;
            enemiesNeededForWave = BAD_GUYS_PER_WAVE[Math.min(wave - 1, BAD_GUYS_PER_WAVE.length - 1)];
            startWave();
        }
        
        function startWave() {
            // Clear all enemies from the screen for the new wave
            enemies = [];
            enemiesNeededForWave = BAD_GUYS_PER_WAVE[Math.min(wave - 1, BAD_GUYS_PER_WAVE.length - 1)];
            let announcements = [
                "PRIVACY BREACH DETECTED!",
                "DATA QUALITY CRISIS!",
                "UNGOVERNED DATA ALERT!",
                "ORPHANED TABLES INCOMING!",
                "UNCLASSIFIED FILES DETECTED!",
                "STALE REPORTS OVERLOAD!",
                "BROKEN LINEAGE LINKS!",
                "DUPLICATE ASSETS ATTACK!",
                "UNAPPROVED QUERIES!",
                "POLICY VIOLATIONS!",
                "UNCERTIFIED DATASETS!",
                "UNKNOWN OWNERS!",
                "FULL SCALE DATA DISASTER!"
            ];
            waveAnnouncement = announcements[Math.min(wave - 1, announcements.length - 1)];
            gameState = 'waveAnnounce';
            waveTimer = 180;
        }
        
        function drawScore() {
            fill(255);
            textAlign(LEFT);
            textSize(16);
            text(`Score: ${score}`, 10, 25);
            text(`Wave: ${wave}`, 10, 45);
            text(`Lives: ${lives}`, 10, 65);
            
            let remaining = enemiesNeededForWave - enemiesKilled;
            fill(255, 255, 0);
            textSize(12);
            text(`Enemies left: ${remaining}`, 10, 85);
        }
        
        function spawnEnemy() {
            // Only spawn if the number of enemies on screen is less than the number of kills left
            if (enemies.length >= enemiesNeededForWave - enemiesKilled) return;
            let typeObj;
            if (wave === 1) {
                typeObj = ENEMY_TYPES[0]; // pii
            } else if (wave === 2) {
                typeObj = ENEMY_TYPES[1]; // quality
            } else if (wave === 3) {
                typeObj = ENEMY_TYPES[2]; // lost
            } else if (wave === 4) {
                typeObj = ENEMY_TYPES[3]; // orphan
            } else if (wave === 5) {
                typeObj = ENEMY_TYPES[4]; // unclassified
            } else if (wave === 6) {
                typeObj = ENEMY_TYPES[5]; // stale
            } else if (wave === 7) {
                typeObj = ENEMY_TYPES[6]; // lineage
            } else if (wave === 8) {
                typeObj = ENEMY_TYPES[7]; // duplicate
            } else if (wave === 9) {
                typeObj = ENEMY_TYPES[8]; // unapproved
            } else if (wave === 10) {
                typeObj = ENEMY_TYPES[9]; // policy
            } else if (wave === 11) {
                typeObj = ENEMY_TYPES[10]; // uncertified
            } else if (wave === 12) {
                typeObj = ENEMY_TYPES[11]; // unknown
            } else {
                // Mixed waves after 12
                typeObj = random(ENEMY_TYPES);
            }
            enemies.push({
                x: random(30, canvasWidth - 30),
                y: -30,
                type: typeObj.type,
                label: typeObj.label,
                color: typeObj.color,
                speed: random(1, 2) + wave * 0.3,
                points: typeObj.points
            });
        }
        
        function createExplosion(x, y, enemyType) {
            let colors = {
                'pii': [255, 50, 50],
                'quality': [150, 150, 150],
                'lost': [139, 69, 19],
                'player': [0, 150, 255]
            };
            
            let color = colors[enemyType] || [255, 255, 255];
            
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: random(-3, 3),
                    vy: random(-3, 3),
                    r: color[0],
                    g: color[1],
                    b: color[2],
                    life: 20
                });
            }
        }
        
        function drawStars() {
            fill(255, 255, 255, 100);
            noStroke();
            for (let i = 0; i < 30; i++) {
                let x = (i * 37) % canvasWidth;
                let y = (i * 23 + frameCount * 0.3) % canvasHeight;
                rect(x, y, 1, 1);
            }
        }
        
        // Audio functions
        function startBackgroundMusic() {
            if (!musicEnabled) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                stopBackgroundMusic(); // Stop any previous melody
                melodyIndex = 0;
                melodyTempo = Math.max(400 - (wave - 1) * 30, MIN_TEMPO); // Increase tempo with wave
                playingVictory = false;
                melodyInterval = setInterval(() => {
                    if ((gameState === 'playing' || gameState === 'waveAnnounce') && musicEnabled && !playingVictory) {
                        playMelodyNote();
                    }
                }, melodyTempo);
            } catch (e) { console.log('startBackgroundMusic error:', e); }
        }
        
        function stopBackgroundMusic() {
            if (melodyInterval) {
                clearInterval(melodyInterval);
                melodyInterval = null;
            }
        }
        
        function playMelodyNote() {
            if (!musicEnabled) return;
            try {
                if (!audioContext) return;
                const freq = MAIN_MELODY[melodyIndex % MAIN_MELODY.length];
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.type = 'sawtooth'; // darker, more ominous
                gainNode.gain.setValueAtTime(0.025, audioContext.currentTime); // slightly lower volume
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.18);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.18);
                melodyIndex++;
            } catch (e) { console.log('playMelodyNote error:', e); }
        }
        
        function playHitSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.07, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.type = 'triangle';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) { console.log('playHitSound error:', e); }
        }
        
        function playDeathSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.4);
                gainNode.gain.setValueAtTime(0.09, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                oscillator.type = 'triangle';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            } catch (e) { console.log('playDeathSound error:', e); }
        }
        
        function playVictoryMelody() {
            if (!musicEnabled) return;
            try {
                playingVictory = true;
                stopBackgroundMusic();
                let idx = 0;
                function playNextVictoryNote() {
                    if (!musicEnabled) return;
                    if (idx >= VICTORY_MELODY.length) {
                        playingVictory = false;
                        startBackgroundMusic();
                        return;
                    }
                    const freq = VICTORY_MELODY[idx];
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'triangle'; // still a bit dark
                    gainNode.gain.setValueAtTime(0.045, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.22);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.22);
                    idx++;
                    setTimeout(playNextVictoryNote, 220);
                }
                playNextVictoryNote();
            } catch (e) { console.log('playVictoryMelody error:', e); }
        }
        
        function setupControls() {
            // Touch controls only
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const fireBtn = document.getElementById('fireBtn');

            // LEFT
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                leftPressed = true;
                console.log('LEFT button touchstart');
            }, { passive: false });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                leftPressed = false;
                console.log('LEFT button touchend');
            }, { passive: false });

            // RIGHT
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                rightPressed = true;
                console.log('RIGHT button touchstart');
            }, { passive: false });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                rightPressed = false;
                console.log('RIGHT button touchend');
            }, { passive: false });

            // FIRE
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                firePressed = true;
                console.log('FIRE button touchstart');
            }, { passive: false });
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                firePressed = false;
                console.log('FIRE button touchend');
            }, { passive: false });

            // Start button
            document.getElementById('startBtn').addEventListener('touchstart', async (e) => {
                e.preventDefault();
                console.log('START button touchstart');
                if (typeof audioContext !== 'undefined' && audioContext && audioContext.state === 'suspended') {
                    console.log('Resuming audioContext...');
                    await audioContext.resume();
                    console.log('audioContext state after resume:', audioContext.state);
                } else if (typeof audioContext === 'undefined' || !audioContext) {
                    console.log('Creating new audioContext...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('audioContext state after creation:', audioContext.state);
                }
                if (gameState === 'title' || gameState === 'gameOver') {
                    score = 0;
                    wave = 1;
                    lives = 3;
                    enemiesKilled = 0;
                    enemiesNeededForWave = 25;
                    bullets = [];
                    enemies = [];
                    particles = [];
                    player.x = canvasWidth / 2;
                    player.y = canvasHeight * PLAYER_Y_RATIO;
                    invulnerableTimer = 0;
                    gameOverTimer = 0;
                    gameState = 'playing';
                    startBackgroundMusic();
                    startWave();
                }
            }, { passive: false });
            
            // Music toggle
            document.getElementById('musicBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                musicEnabled = !musicEnabled;
                const musicBtn = document.getElementById('musicBtn');
                console.log('MUSIC button touchstart, musicEnabled:', musicEnabled);
                if (musicEnabled) {
                    musicBtn.textContent = 'MUSIC ON';
                    musicBtn.classList.remove('off');
                    if (gameState === 'playing' || gameState === 'waveAnnounce') {
                        startBackgroundMusic();
                    }
                } else {
                    musicBtn.textContent = 'MUSIC OFF';
                    musicBtn.classList.add('off');
                    stopBackgroundMusic();
                }
            }, { passive: false });
            
            // Quit button
            document.getElementById('quitBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                console.log('QUIT button touchstart');
                score = 0;
                wave = 1;
                lives = 3;
                enemiesKilled = 0;
                enemiesNeededForWave = 25;
                bullets = [];
                enemies = [];
                particles = [];
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
                invulnerableTimer = 0;
                gameOverTimer = 0;
                gameState = 'title';
                stopBackgroundMusic();
            }, { passive: false });
        }
        
        function windowResized() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            resizeCanvas(canvasWidth, canvasHeight);
            if (player) {
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
            }
        }

        // Draw a standard explosion sprite
        function drawExplosion(explosion) {
            push();
            translate(explosion.x, explosion.y);
            let progress = 1 - explosion.timer / 30;
            let radius = 10 + 30 * progress;
            noStroke();
            fill(255, 200, 0, 180 - 120 * progress);
            ellipse(0, 0, radius * 1.2, radius * 1.2);
            fill(255, 100, 0, 120 - 80 * progress);
            ellipse(0, 0, radius * 0.8, radius * 0.8);
            fill(255, 255, 255, 100 - 80 * progress);
            ellipse(0, 0, radius * 0.4, radius * 0.4);
            pop();
        }
    </script>
</body>
</html>