<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlan Data Defender</title>
    <link rel="icon" type="image/png" href="images/atlan_ship_icon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
        }
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw;
            max-height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: auto;
        }
        .btn {
            width: 80px;
            height: 80px;
            background: rgba(0, 100, 255, 0.8);
            border: 2px solid #00ffff;
            border-radius: 50%;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
            pointer-events: auto;
        }
        /* Add spacing control for right button */
        .btn#rightBtn {
            margin-left: -60px; /* Adjust this value to move right button closer to left (-40px = closer, 0px = default spacing) */
        }
        .btn:active {
            background: rgba(0, 150, 255, 1);
            transform: scale(0.95);
        }
        .btn.fire {
            background: rgba(255, 50, 50, 0.8);
            border-color: #ff0000;
        }
        .btn.fire:active {
            background: rgba(255, 100, 100, 1);
        }
        .start-btn, .music-btn, .quit-btn {
            position: fixed;
            z-index: 101;
            pointer-events: auto;
        }
        .start-btn {
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 50px;
            background: rgba(255, 255, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 10px;
            color: #000;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .start-btn:active {
            background: rgba(255, 255, 100, 1);
            transform: translateX(-50%) scale(0.95);
        }
        .start-btn.hidden {
            display: none;
        }
        .music-btn {
            top: 5px;
            right: 80px;
            width: 70px;
            height: 25px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
            border-radius: 5px;
            color: #0f0;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .music-btn:active {
            background: rgba(0, 255, 0, 0.4);
        }
        .music-btn.off {
            background: rgba(255, 0, 0, 0.2);
            border-color: #f00;
            color: #f00;
        }
        .music-btn.off:active {
            background: rgba(255, 0, 0, 0.4);
        }
        .quit-btn {
            top: 5px;
            right: 10px;
            width: 60px;
            height: 25px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }
        .quit-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div class="controls">
        <div class="btn" id="leftBtn">LEFT</div>
        <div class="btn" id="rightBtn">RIGHT</div>
        <div class="btn fire" id="fireBtn">FIRE</div>
    </div>
    <div class="start-btn" id="startBtn">START GAME</div>
    <div class="music-btn" id="musicBtn">MUSIC ON</div>
    <div class="quit-btn" id="quitBtn">QUIT</div>
    <div id="version" style="position:fixed;bottom:5px;right:10px;font-size:12px;color:#aaa;z-index:200;pointer-events:none;">v<span id="versionNum"></span></div>

    <script>
        // === GLOBAL GAME CONSTANTS ===
        // Versioning
        const GAME_VERSION = '1.3.9'; // Simplified bonus life ship removal logic

        // --- Volume Control ---
        const BACKGROUND_MUSIC_VOLUME = 0.7;  // Volume for background music (0.0 to 1.0)
        const SOUND_EFFECTS_VOLUME = 0.4;      // Volume for all other sound effects (0.0 to 1.0)

        // --- Player Settings ---
        const PLAYER_START_LIVES = 3; // Number of lives per game
        const PLAYER_SPEED = 4;       // Horizontal speed of player ship
        const PLAYER_WIDTH = 40;      // Width of player ship
        const PLAYER_HEIGHT = 30;     // Height of player ship
        const PLAYER_Y_RATIO = 0.75;  // Vertical position ratio (0.9 = near bottom, 0.5 = middle)
        const PLAYER_INVULNERABLE_FRAMES = 180; // Frames of invulnerability after hit

        // --- Bullet Settings ---
        const BULLET_SPEED = 8;       // Speed of player bullets
        const BULLET_WIDTH = 4;       // Width of bullet
        const BULLET_HEIGHT = 12;     // Height of bullet
        const MAX_BULLETS = 1;        // Max bullets on screen at once

        // --- Enemy & Wave Settings ---
        const BAD_GUYS_PER_WAVE = [   // Number of enemies to defeat per wave
            25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85
        ];
        const ENEMY_SPAWN_BASE = 30;  // Base spawn interval (frames)
        const ENEMY_SPAWN_DECREASE = 3; // Spawn interval decrease per wave
        const ENEMY_SPAWN_MIN = 10;   // Minimum spawn interval (frames)
        const ENEMY_SPEED_SCALE = 0.3; // Additional speed per wave
        const ENEMY_START_Y = -30;    // Y position where enemies spawn
        const ENEMY_MIN_X = 30;       // Min X for enemy spawn
        const ENEMY_MAX_X_OFFSET = 30;// Max X offset for enemy spawn
        const BONUS_LIFE_CHANCE = 0.02; // 2% chance for bonus life enemy to spawn (reduced from 5%)
        const BONUS_LIFE_SPEED = 2;   // Speed of bonus life enemy
        const BONUS_LIFE_DESPAWN_Y = 50; // Y position where bonus life enemy despawns

        // --- Wave Announcement & Game Over ---
        const WAVE_ANNOUNCE_FRAMES = 180; // Frames to show wave announcement
        const PLAYER_HIT_FRAMES = 120;    // Frames to show player hit screen
        const GAME_OVER_FRAMES = 300;     // Frames to show game over screen

        // --- Explosion/Particle Settings ---
        const EXPLOSION_PARTICLES = 8;    // Number of particles per explosion
        const PARTICLE_LIFE = 20;         // Frames each particle lasts
        const EXPLOSION_FRAMES = 30;      // Frames explosion animation lasts

        // --- Music Settings ---
        const MAIN_MELODY = [220, 261.63, 329.63, 349.23, 329.63, 261.63]; // Minor key
        const VICTORY_MELODY = [220, 261.63, 349.23, 440];
        const MUSIC_TEMPO_BASE = 400;     // ms per note at wave 1
        const MUSIC_TEMPO_DECREASE = 30;  // ms decrease per wave
        const MUSIC_TEMPO_MIN = 120;      // Fastest allowed (ms per note)

        // --- Canvas/Display Settings ---
        const STAR_COUNT = 30;            // Number of background stars
        const STAR_X_STEP = 37;           // Star X spacing
        const STAR_Y_STEP = 23;           // Star Y spacing
        const STAR_SCROLL_SPEED = 0.3;    // Star vertical scroll speed
        
        // Game state and music variables
        let gameState = 'title';
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let score = 0;
        let wave = 1;
        let lives = 3;
        let waveTimer = 0;
        let waveAnnouncement = '';
        let invulnerableTimer = 0;
        let gameOverTimer = 0;
        let enemiesKilled = 0;
        let enemiesNeededForWave = 25;
        let hitTimer = 0;
        let explosions = [];
        let bonusLifeActive = false; // Track if a bonus life enemy is currently on screen
        // --- Music globals ---
        let melodyIndex = 0;
        let melodyTempo = MUSIC_TEMPO_BASE;
        let melodyInterval = null;
        let playingVictory = false;
        
        // Controls
        let leftPressed = false;
        let rightPressed = false;
        let firePressed = false;
        
        // Audio
        let audioContext;
        let backgroundMusic;
        let musicEnabled = true;
        
        // Game settings
        let canvasWidth = 400;
        let canvasHeight = 600;
        
        // Data catalog-themed enemy definitions
        const ENEMY_TYPES = [
            { type: 'pii', label: 'PII Breach', color: [120, 0, 0], points: 30 }, // deep red
            { type: 'quality', label: 'Bad Quality', color: [60, 60, 60], points: 20 }, // dark gray
            { type: 'lost', label: 'Lost Data', color: [70, 35, 10], points: 10 }, // dark brown
            { type: 'orphan', label: 'Orphaned Table', color: [0, 80, 120], points: 25 }, // dark cyan
            { type: 'unclassified', label: 'Unclassified File', color: [120, 90, 0], points: 18 }, // dark gold
            { type: 'stale', label: 'Stale Report', color: [60, 60, 100], points: 15 }, // dark blue-gray
            { type: 'lineage', label: 'Broken Lineage', color: [90, 0, 80], points: 22 }, // dark magenta
            { type: 'duplicate', label: 'Duplicate Asset', color: [0, 80, 30], points: 16 }, // dark green
            { type: 'unapproved', label: 'Unapproved Query', color: [120, 40, 0], points: 20 }, // dark orange
            { type: 'policy', label: 'Policy Violation', color: [120, 0, 0], points: 28 }, // deep red
            { type: 'uncertified', label: 'Uncertified Data', color: [30, 30, 80], points: 19 }, // dark blue
            { type: 'unknown', label: 'Unknown Owner', color: [30, 80, 80], points: 17 }, // dark teal
            { type: 'bonus', label: 'BONUS LIFE!', color: [255, 215, 0], points: 50, isBonus: true } // gold
        ];
        
        // Atlan logo SVG
        let atlanLogoImg;
        
        function preload() {
            atlanLogoImg = loadImage('images/atlan_logo.svg');
        }
        
        function setup() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('gameContainer');
            player = {
                x: canvasWidth / 2,
                y: canvasHeight * PLAYER_Y_RATIO, // Use global var for vertical placement
                width: 40,
                height: 30,
                speed: 4
            };
            setupControls();
            // At the end of setup() or after DOM is ready, set the version number
            window.addEventListener('DOMContentLoaded', () => {
                document.getElementById('versionNum').textContent = GAME_VERSION;
            });
        }
        
        function draw() {
            background(10, 10, 30);
            drawStars();
            
            if (gameState === 'title') {
                drawTitle();
                document.getElementById('startBtn').classList.remove('hidden');
            } else if (gameState === 'playing') {
                updateGame();
                drawGame();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'waveAnnounce') {
                drawWaveAnnouncement();
                updateWaveTimer();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'playerHit') {
                drawPlayerHit();
                updateHitTimer();
                document.getElementById('startBtn').classList.add('hidden');
            } else if (gameState === 'gameOver') {
                drawGameOver();
                updateGameOverTimer();
                document.getElementById('startBtn').classList.remove('hidden');
            }
            
            if (gameState !== 'gameOver') {
                drawScore();
            }
        }
        
        function updateGame() {
            // Controls
            if (leftPressed && player.x > player.width/2) {
                player.x -= player.speed;
            }
            if (rightPressed && player.x < canvasWidth - player.width/2) {
                player.x += player.speed;
            }
            if (firePressed && bullets.length === 0) {
                bullets.push({
                    x: player.x,
                    y: player.y - 10,
                    speed: 8
                });
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                if (bullets[i].y < 0) {
                    bullets.splice(i, 1);
                }
            }
            
            // Spawn enemies
            if (frameCount % max(30 - wave * 3, 10) === 0) {
                spawnEnemy();
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;
                
                // Remove any enemy that goes off screen
                if (enemies[i].y > canvasHeight + 50) {
                    // If it was a bonus life ship, reset the active flag
                    if (enemies[i].isBonus) {
                        bonusLifeActive = false;
                    }
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Player collision
                if (invulnerableTimer <= 0 && dist(enemies[i].x, enemies[i].y, player.x, player.y) < 30) {
                    lives--;
                    invulnerableTimer = 180;
                    createExplosion(player.x, player.y, 'player');
                    playDeathSound();
                    enemies.splice(i, 1);
                    
                    if (lives <= 0) {
                        lives = 0;
                        gameState = 'gameOver';
                        gameOverTimer = 300;
                        stopBackgroundMusic();
                        return;
                    } else {
                        // Clear all enemies when player is hit
                        enemies = [];
                        gameState = 'playerHit';
                        hitTimer = 120;
                        return;
                    }
                    continue;
                }
            }
            
            if (invulnerableTimer > 0) {
                invulnerableTimer--;
            }
            
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (dist(bullets[i].x, bullets[i].y, enemies[j].x, enemies[j].y) < 20) {
                        // Add explosion sprite at enemy position
                        explosions.push({
                            x: enemies[j].x,
                            y: enemies[j].y,
                            timer: 30,
                            frame: 0
                        });
                        
                        if (enemies[j].isBonus) {
                            playBonusLifeSound();
                            lives = min(lives + 1, 5); // Cap at 5 lives
                            bonusLifeActive = false; // Reset bonus life active flag
                            // Create special bonus explosion
                            for (let k = 0; k < 20; k++) {
                                particles.push({
                                    x: enemies[j].x,
                                    y: enemies[j].y,
                                    vx: random(-4, 4),
                                    vy: random(-4, 4),
                                    r: 255,
                                    g: 215,
                                    b: 0,
                                    life: 30
                                });
                            }
                        } else {
                            playHitSound();
                        }
                        
                        score += enemies[j].points;
                        enemiesKilled++;
                        
                        if (enemiesKilled >= enemiesNeededForWave) {
                            playVictoryMelody();
                            nextWave();
                        }
                        
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        break;
                    }
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life--;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].timer--;
                explosions[i].frame++;
                if (explosions[i].timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function drawGame() {
            // Draw player
            if (invulnerableTimer <= 0 || frameCount % 10 < 5) {
                drawAtlanShip(player.x, player.y);
            }
            
            // Draw bullets
            fill(255, 255, 0);
            noStroke();
            for (let bullet of bullets) {
                rect(bullet.x - 2, bullet.y - 6, 4, 12);
            }
            
            // Draw enemies
            for (let enemy of enemies) {
                drawEnemy(enemy);
            }
            
            // Draw explosions
            for (let explosion of explosions) {
                drawExplosion(explosion);
            }
            
            // Draw particles
            for (let particle of particles) {
                fill(particle.r, particle.g, particle.b, particle.life * 3);
                noStroke();
                rect(particle.x, particle.y, 3, 3);
            }
        }
        
        function drawAtlanShip(x, y) {
            push();
            translate(x, y);
            
            // Main body
            fill(0, 150, 255);
            noStroke();
            beginShape();
            vertex(-15, -10);  // Top left
            vertex(15, -10);   // Top right
            vertex(20, 0);     // Right middle
            vertex(15, 10);    // Bottom right
            vertex(-15, 10);   // Bottom left
            vertex(-20, 0);    // Left middle
            endShape(CLOSE);
            
            // Cockpit
            fill(255, 255, 255);
            beginShape();
            vertex(-8, -6);
            vertex(8, -6);
            vertex(6, 6);
            vertex(-6, 6);
            endShape(CLOSE);
            
            // Wings
            fill(0, 100, 200);
            beginShape();
            vertex(-20, 0);
            vertex(-25, 5);
            vertex(-20, 10);
            endShape(CLOSE);
            
            beginShape();
            vertex(20, 0);
            vertex(25, 5);
            vertex(20, 10);
            endShape(CLOSE);
            
            // Engines
            fill(255, 100, 0);
            rect(-6, 10, 4, 8);
            rect(2, 10, 4, 8);
            
            // Engine glow
            fill(255, 200, 0, 150);
            rect(-6, 18, 4, 4);
            rect(2, 18, 4, 4);
            
            pop();
        }
        
        function drawEnemy(enemy) {
            push();
            translate(enemy.x, enemy.y);
            noStroke();
            
            if (enemy.isBonus) {
                // Draw bonus life enemy (golden shield with pulsing effect)
                let pulse = sin(frameCount * 0.1) * 0.2 + 0.8; // Pulsing effect
                fill(255, 215, 0, 200 * pulse); // Gold color with pulse
                ellipse(0, 0, 30, 30);
                fill(255, 255, 255, 200 * pulse);
                ellipse(0, 0, 20, 20);
                fill(255, 215, 0, 200 * pulse);
                ellipse(0, 0, 10, 10);
                
                // Draw shield effect
                noFill();
                stroke(255, 215, 0, 150 * pulse);
                strokeWeight(2);
                ellipse(0, 0, 35, 35);
                ellipse(0, 0, 40, 40);
                noStroke();
            } else {
                // Existing enemy drawing code
                if (enemy.type === 'pii') {
                    // Red demon head with horns and glowing yellow eyes
                    fill(220, 0, 0);
                    ellipse(0, 0, 28, 28);
                    fill(255, 255, 0);
                    ellipse(-7, -4, 6, 8); // left eye
                    ellipse(7, -4, 6, 8); // right eye
                    fill(120, 0, 0);
                    arc(0, 8, 16, 10, 0, PI, CHORD); // mouth
                    fill(255, 255, 255);
                    triangle(-10, -14, -4, -18, -2, -8); // left horn
                    triangle(10, -14, 4, -18, 2, -8); // right horn
                } else if (enemy.type === 'quality') {
                    // Gray cyclops blob with a big green eye and fangs
                    fill(80, 80, 80);
                    ellipse(0, 0, 30, 24);
                    fill(0, 255, 0);
                    ellipse(0, -2, 10, 10); // big eye
                    fill(0);
                    ellipse(0, -2, 4, 4); // pupil
                    fill(255);
                    triangle(-4, 8, -2, 12, 0, 8); // left fang
                    triangle(4, 8, 2, 12, 0, 8); // right fang
                } else if (enemy.type === 'lost') {
                    // Brown spiky virus with glowing orange core
                    fill(120, 60, 20);
                    ellipse(0, 0, 24, 24);
                    for (let a = 0; a < TWO_PI; a += PI/4) {
                        let x1 = cos(a) * 12, y1 = sin(a) * 12;
                        let x2 = cos(a) * 18, y2 = sin(a) * 18;
                        stroke(120, 60, 20);
                        strokeWeight(3);
                        line(x1, y1, x2, y2);
                    }
                    noStroke();
                    fill(255, 140, 0, 180);
                    ellipse(0, 0, 10, 10);
                } else if (enemy.type === 'orphan') {
                    // Blue floating jellyfish with tentacles and glowing eyes
                    fill(0, 180, 255);
                    ellipse(0, 0, 26, 18);
                    fill(255, 255, 255, 200);
                    ellipse(-5, -2, 5, 5);
                    ellipse(5, -2, 5, 5);
                    stroke(0, 180, 255);
                    strokeWeight(2);
                    for (let t = -1; t <= 1; t++) {
                        line(t*6, 8, t*6 + random(-2,2), 18 + random(0,2));
                    }
                    noStroke();
                } else if (enemy.type === 'unclassified') {
                    // Yellow-green alien with three eyes and a jagged mouth
                    fill(200, 220, 0);
                    ellipse(0, 0, 24, 24);
                    fill(0, 255, 0);
                    ellipse(-6, -4, 4, 4);
                    ellipse(0, -7, 4, 4);
                    ellipse(6, -4, 4, 4);
                    fill(0);
                    beginShape();
                    vertex(-6, 7);
                    vertex(-3, 10);
                    vertex(0, 7);
                    vertex(3, 10);
                    vertex(6, 7);
                    endShape();
                } else if (enemy.type === 'stale') {
                    // Purple bat-like alien with wings
                    fill(120, 0, 180);
                    ellipse(0, 0, 22, 16);
                    fill(180, 0, 255, 180);
                    triangle(-11, 0, -22, 8, -8, 8);
                    triangle(11, 0, 22, 8, 8, 8);
                    fill(255, 255, 255);
                    ellipse(-4, -2, 3, 3);
                    ellipse(4, -2, 3, 3);
                } else if (enemy.type === 'lineage') {
                    // Magenta tentacled alien with a single red eye
                    fill(200, 0, 120);
                    ellipse(0, 0, 20, 20);
                    stroke(200, 0, 120);
                    strokeWeight(2);
                    for (let t = -1; t <= 1; t++) {
                        line(t*6, 8, t*6 + random(-2,2), 18 + random(0,2));
                    }
                    noStroke();
                    fill(255, 0, 0);
                    ellipse(0, -3, 6, 6);
                    fill(0);
                    ellipse(0, -3, 2, 2);
                } else if (enemy.type === 'duplicate') {
                    // Green two-headed alien
                    fill(0, 220, 80);
                    ellipse(-5, 0, 12, 16);
                    ellipse(5, 0, 12, 16);
                    fill(255);
                    ellipse(-5, -4, 3, 3);
                    ellipse(5, -4, 3, 3);
                    fill(255, 0, 0);
                    ellipse(-5, 2, 2, 2);
                    ellipse(5, 2, 2, 2);
                } else if (enemy.type === 'unapproved') {
                    // Orange spiky alien with angry eyes
                    fill(255, 120, 0);
                    ellipse(0, 0, 22, 22);
                    for (let a = 0; a < TWO_PI; a += PI/5) {
                        let x1 = cos(a) * 11, y1 = sin(a) * 11;
                        let x2 = cos(a) * 15, y2 = sin(a) * 15;
                        stroke(255, 120, 0);
                        strokeWeight(2);
                        line(x1, y1, x2, y2);
                    }
                    noStroke();
                    fill(0);
                    ellipse(-4, -3, 3, 4);
                    ellipse(4, -3, 3, 4);
                    fill(255, 0, 0);
                    rect(-3, 4, 6, 2, 1);
                } else if (enemy.type === 'policy') {
                    // Red skull with glowing eyes
                    fill(255, 0, 0);
                    ellipse(0, 0, 22, 22);
                    fill(255, 255, 0);
                    ellipse(-5, -3, 4, 4);
                    ellipse(5, -3, 4, 4);
                    fill(0);
                    rect(-6, 4, 12, 4, 2);
                    rect(-2, 8, 4, 2, 1);
                } else if (enemy.type === 'uncertified') {
                    // Blue floating orb with a glowing core and aura
                    fill(0, 80, 255);
                    ellipse(0, 0, 20, 20);
                    fill(0, 200, 255, 120);
                    ellipse(0, 0, 12, 12);
                    fill(255, 255, 255, 180);
                    ellipse(0, 0, 6, 6);
                } else if (enemy.type === 'unknown') {
                    // Teal alien with a single big eye and question mark
                    fill(0, 200, 200);
                    ellipse(0, 0, 22, 22);
                    fill(255);
                    ellipse(0, -3, 7, 7);
                    fill(0);
                    ellipse(0, -3, 3, 3);
                    fill(255, 255, 0);
                    textSize(14);
                    text('?', 0, 8);
                }
            }
            // Draw label under enemy
            pop();
            push();
            translate(enemy.x, enemy.y);
            fill(255);
            textAlign(CENTER);
            textSize(10);
            text(enemy.label, 0, 22);
            pop();
        }
        
        function drawTitle() {
            if (frameCount % 60 === 0) {
                const typeObj = random(ENEMY_TYPES.slice(0, 3)); // Only the first 3 for title screen
                enemies.push({
                    x: random(50, canvasWidth - 50),
                    y: -30,
                    type: typeObj.type,
                    label: typeObj.label,
                    color: typeObj.color,
                    speed: 0.5,
                    points: typeObj.points
                });
            }
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;
                drawEnemy(enemies[i]);
                if (enemies[i].y > canvasHeight + 50) {
                    enemies.splice(i, 1);
                }
            }
            // Draw Atlan SVG logo centered above DATA DEFENDER
            if (atlanLogoImg) {
                textSize(20);
                let dataDefenderWidth = textWidth("DATA DEFENDER");
                let logoW = dataDefenderWidth * 2;
                let logoH = logoW * (atlanLogoImg.height / atlanLogoImg.width);
                image(atlanLogoImg, canvasWidth/2 - logoW/2, canvasHeight/2 - 170, logoW, logoH);
            }
            fill(255, 255, 255);
            textAlign(CENTER);
            textSize(20);
            text("DATA DEFENDER", canvasWidth/2, canvasHeight/2 - 35);
            fill(255, 255, 0);
            textSize(14);
            text("Protect Your Data!", canvasWidth/2, canvasHeight/2 - 10);
            fill(255, 255, 0);
            textSize(14);
            text("version " + GAME_VERSION, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function drawPlayerHit() {
            for (let enemy of enemies) {
                drawEnemy(enemy);
            }
            
            for (let particle of particles) {
                fill(particle.r, particle.g, particle.b, particle.life * 3);
                noStroke();
                rect(particle.x, particle.y, 3, 3);
            }
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life--;
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            fill(255, 100, 100);
            textAlign(CENTER);
            textSize(24);
            text("SHIP HIT!", canvasWidth/2, canvasHeight/2 - 20);
            
            fill(255, 255, 255);
            textSize(16);
            text(`Lives Remaining: ${lives}`, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function updateHitTimer() {
            hitTimer--;
            if (hitTimer <= 0) {
                gameState = 'playing';
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
            }
        }
        
        function drawWaveAnnouncement() {
            fill(255, 255, 0);
            textAlign(CENTER);
            textSize(20);
            text(`WAVE ${wave}`, canvasWidth/2, canvasHeight/2 - 20);
            textSize(14);
            text(waveAnnouncement, canvasWidth/2, canvasHeight/2 + 10);
        }
        
        function updateWaveTimer() {
            waveTimer--;
            if (waveTimer <= 0) {
                gameState = 'playing';
            }
        }
        
        function drawGameOver() {
            fill(255, 0, 0);
            textAlign(CENTER);
            textSize(28);
            text("GAME OVER", canvasWidth/2, canvasHeight/2 - 80);
            
            fill(255);
            textSize(18);
            text(`Final Score: ${score}`, canvasWidth/2, canvasHeight/2 - 40);
            text(`Waves Survived: ${wave}`, canvasWidth/2, canvasHeight/2 - 15);
        }
        
        function updateGameOverTimer() {
            gameOverTimer--;
            if (gameOverTimer <= 0) {
                lives = 3;
                gameState = 'title';
            }
        }
        
        function nextWave() {
            wave++;
            enemiesKilled = 0;
            enemiesNeededForWave = BAD_GUYS_PER_WAVE[Math.min(wave - 1, BAD_GUYS_PER_WAVE.length - 1)];
            startWave();
        }
        
        function startWave() {
            // Clear all enemies from the screen for the new wave
            enemies = [];
            enemiesNeededForWave = BAD_GUYS_PER_WAVE[Math.min(wave - 1, BAD_GUYS_PER_WAVE.length - 1)];
            let announcements = [
                "PRIVACY BREACH DETECTED!",
                "DATA QUALITY CRISIS!",
                "UNGOVERNED DATA ALERT!",
                "ORPHANED TABLES INCOMING!",
                "UNCLASSIFIED FILES DETECTED!",
                "STALE REPORTS OVERLOAD!",
                "BROKEN LINEAGE LINKS!",
                "DUPLICATE ASSETS ATTACK!",
                "UNAPPROVED QUERIES!",
                "POLICY VIOLATIONS!",
                "UNCERTIFIED DATASETS!",
                "UNKNOWN OWNERS!",
                "FULL SCALE DATA DISASTER!"
            ];
            waveAnnouncement = announcements[Math.min(wave - 1, announcements.length - 1)];
            gameState = 'waveAnnounce';
            waveTimer = 180;
        }
        
        function drawScore() {
            fill(255);
            textAlign(LEFT);
            textSize(16);
            text(`Score: ${score}`, 10, 25);
            text(`Wave: ${wave}`, 10, 45);
            text(`Lives: ${lives}`, 10, 65);
            
            let remaining = enemiesNeededForWave - enemiesKilled;
            fill(255, 255, 0);
            textSize(12);
            text(`Enemies left: ${remaining}`, 10, 85);
        }
        
        function spawnEnemy() {
            // Only spawn if the number of enemies on screen is less than the number of kills left
            if (enemies.length >= enemiesNeededForWave - enemiesKilled) return;
            
            // Check for bonus life enemy spawn
            let typeObj;
            if (wave > 1 && !bonusLifeActive && random() < BONUS_LIFE_CHANCE) {
                typeObj = ENEMY_TYPES.find(e => e.type === 'bonus');
                bonusLifeActive = true; // Mark that a bonus enemy is active
            } else {
                if (wave === 1) {
                    typeObj = ENEMY_TYPES[0]; // pii
                } else if (wave === 2) {
                    typeObj = ENEMY_TYPES[1]; // quality
                } else if (wave === 3) {
                    typeObj = ENEMY_TYPES[2]; // lost
                } else if (wave === 4) {
                    typeObj = ENEMY_TYPES[3]; // orphan
                } else if (wave === 5) {
                    typeObj = ENEMY_TYPES[4]; // unclassified
                } else if (wave === 6) {
                    typeObj = ENEMY_TYPES[5]; // stale
                } else if (wave === 7) {
                    typeObj = ENEMY_TYPES[6]; // lineage
                } else if (wave === 8) {
                    typeObj = ENEMY_TYPES[7]; // duplicate
                } else if (wave === 9) {
                    typeObj = ENEMY_TYPES[8]; // unapproved
                } else if (wave === 10) {
                    typeObj = ENEMY_TYPES[9]; // policy
                } else if (wave === 11) {
                    typeObj = ENEMY_TYPES[10]; // uncertified
                } else if (wave === 12) {
                    typeObj = ENEMY_TYPES[11]; // unknown
                } else {
                    // Mixed waves after 12
                    typeObj = random(ENEMY_TYPES.filter(e => e.type !== 'bonus')); // Exclude bonus from random selection
                }
            }
            
            enemies.push({
                x: random(30, canvasWidth - 30),
                y: -30,
                type: typeObj.type,
                label: typeObj.label,
                color: typeObj.color,
                speed: typeObj.type === 'bonus' ? BONUS_LIFE_SPEED : (random(1, 2) + wave * 0.3),
                points: typeObj.points,
                isBonus: typeObj.isBonus || false
            });
        }
        
        function createExplosion(x, y, enemyType) {
            let colors = {
                'pii': [255, 50, 50],
                'quality': [150, 150, 150],
                'lost': [139, 69, 19],
                'player': [0, 150, 255]
            };
            
            let color = colors[enemyType] || [255, 255, 255];
            
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: random(-3, 3),
                    vy: random(-3, 3),
                    r: color[0],
                    g: color[1],
                    b: color[2],
                    life: 20
                });
            }
        }
        
        function drawStars() {
            fill(255, 255, 255, 100);
            noStroke();
            for (let i = 0; i < 30; i++) {
                let x = (i * 37) % canvasWidth;
                let y = (i * 23 + frameCount * 0.3) % canvasHeight;
                rect(x, y, 1, 1);
            }
        }
        
        // Audio functions
        function startBackgroundMusic() {
            if (!musicEnabled) return;
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                stopBackgroundMusic(); // Stop any previous melody
                melodyIndex = 0;
                melodyTempo = Math.max(MUSIC_TEMPO_BASE - (wave - 1) * MUSIC_TEMPO_DECREASE, MUSIC_TEMPO_MIN); // Increase tempo with wave
                playingVictory = false;
                melodyInterval = setInterval(() => {
                    if ((gameState === 'playing' || gameState === 'waveAnnounce') && musicEnabled && !playingVictory) {
                        playMelodyNote();
                    }
                }, melodyTempo);
            } catch (e) { console.log('startBackgroundMusic error:', e); }
        }
        
        function stopBackgroundMusic() {
            if (melodyInterval) {
                clearInterval(melodyInterval);
                melodyInterval = null;
            }
        }
        
        function playMelodyNote() {
            if (!musicEnabled) return;
            try {
                if (!audioContext) return;
                const freq = MAIN_MELODY[melodyIndex % MAIN_MELODY.length];
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.type = 'sawtooth'; // darker, more ominous
                gainNode.gain.setValueAtTime(BACKGROUND_MUSIC_VOLUME, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.18);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.18);
                melodyIndex++;
            } catch (e) { console.log('playMelodyNote error:', e); }
        }
        
        function playHitSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                gainNode.gain.setValueAtTime(SOUND_EFFECTS_VOLUME, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.type = 'triangle';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) { console.log('playHitSound error:', e); }
        }
        
        function playDeathSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.4);
                gainNode.gain.setValueAtTime(SOUND_EFFECTS_VOLUME, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                oscillator.type = 'triangle';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            } catch (e) { console.log('playDeathSound error:', e); }
        }
        
        function playVictoryMelody() {
            if (!musicEnabled) return;
            try {
                playingVictory = true;
                stopBackgroundMusic();
                let idx = 0;
                function playNextVictoryNote() {
                    if (!musicEnabled) return;
                    if (idx >= VICTORY_MELODY.length) {
                        playingVictory = false;
                        startBackgroundMusic();
                        return;
                    }
                    const freq = VICTORY_MELODY[idx];
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'triangle'; // still a bit dark
                    gainNode.gain.setValueAtTime(BACKGROUND_MUSIC_VOLUME, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.22);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.22);
                    idx++;
                    setTimeout(playNextVictoryNote, 220);
                }
                playNextVictoryNote();
            } catch (e) { console.log('playVictoryMelody error:', e); }
        }
        
        function playBonusLifeSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Play an ascending arpeggio
                const notes = [440, 554.37, 659.25, 880]; // A4, C#5, E5, A5
                let time = audioContext.currentTime;
                
                notes.forEach((freq, i) => {
                    oscillator.frequency.setValueAtTime(freq, time + i * 0.1);
                    gainNode.gain.setValueAtTime(SOUND_EFFECTS_VOLUME, time + i * 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, time + i * 0.1 + 0.1);
                });
                
                oscillator.type = 'sine';
                oscillator.start(time);
                oscillator.stop(time + 0.5);
            } catch (e) { console.log('playBonusLifeSound error:', e); }
        }
        
        function setupControls() {
            // Touch controls only
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const fireBtn = document.getElementById('fireBtn');

            // LEFT
            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                leftPressed = true;
                console.log('LEFT button touchstart');
            }, { passive: false });
            leftBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                leftPressed = false;
                console.log('LEFT button touchend');
            }, { passive: false });

            // RIGHT
            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                rightPressed = true;
                console.log('RIGHT button touchstart');
            }, { passive: false });
            rightBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                rightPressed = false;
                console.log('RIGHT button touchend');
            }, { passive: false });

            // FIRE
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                firePressed = true;
                console.log('FIRE button touchstart');
            }, { passive: false });
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                firePressed = false;
                console.log('FIRE button touchend');
            }, { passive: false });

            // Start button
            document.getElementById('startBtn').addEventListener('touchstart', async (e) => {
                e.preventDefault();
                console.log('START button touchstart');
                if (typeof audioContext !== 'undefined' && audioContext && audioContext.state === 'suspended') {
                    console.log('Resuming audioContext...');
                    await audioContext.resume();
                    console.log('audioContext state after resume:', audioContext.state);
                } else if (typeof audioContext === 'undefined' || !audioContext) {
                    console.log('Creating new audioContext...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('audioContext state after creation:', audioContext.state);
                }
                if (gameState === 'title' || gameState === 'gameOver') {
                    score = 0;
                    wave = 1;
                    lives = 3;
                    enemiesKilled = 0;
                    enemiesNeededForWave = 25;
                    bullets = [];
                    enemies = [];
                    particles = [];
                    player.x = canvasWidth / 2;
                    player.y = canvasHeight * PLAYER_Y_RATIO;
                    invulnerableTimer = 0;
                    gameOverTimer = 0;
                    gameState = 'playing';
                    startBackgroundMusic();
                    startWave();
                }
            }, { passive: false });
            
            // Music toggle
            document.getElementById('musicBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                musicEnabled = !musicEnabled;
                const musicBtn = document.getElementById('musicBtn');
                console.log('MUSIC button touchstart, musicEnabled:', musicEnabled);
                if (musicEnabled) {
                    musicBtn.textContent = 'MUSIC ON';
                    musicBtn.classList.remove('off');
                    if (gameState === 'playing' || gameState === 'waveAnnounce') {
                        startBackgroundMusic();
                    }
                } else {
                    musicBtn.textContent = 'MUSIC OFF';
                    musicBtn.classList.add('off');
                    stopBackgroundMusic();
                }
            }, { passive: false });
            
            // Quit button
            document.getElementById('quitBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                console.log('QUIT button touchstart');
                score = 0;
                wave = 1;
                lives = 3;
                enemiesKilled = 0;
                enemiesNeededForWave = 25;
                bullets = [];
                enemies = [];
                particles = [];
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
                invulnerableTimer = 0;
                gameOverTimer = 0;
                gameState = 'title';
                stopBackgroundMusic();
            }, { passive: false });
        }
        
        function windowResized() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            resizeCanvas(canvasWidth, canvasHeight);
            if (player) {
                player.x = canvasWidth / 2;
                player.y = canvasHeight * PLAYER_Y_RATIO;
            }
        }

        // Draw a standard explosion sprite
        function drawExplosion(explosion) {
            push();
            translate(explosion.x, explosion.y);
            let progress = 1 - explosion.timer / 30;
            let radius = 10 + 30 * progress;
            noStroke();
            fill(255, 200, 0, 180 - 120 * progress);
            ellipse(0, 0, radius * 1.2, radius * 1.2);
            fill(255, 100, 0, 120 - 80 * progress);
            ellipse(0, 0, radius * 0.8, radius * 0.8);
            fill(255, 255, 255, 100 - 80 * progress);
            ellipse(0, 0, radius * 0.4, radius * 0.4);
            pop();
        }
    </script>
</body>
</html>